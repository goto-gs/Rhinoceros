memo
２章　字句構造
あんまり書く事ない。
JSのインタプリタが優秀だなぁ。くらい。
var a
a
=
3
console.log(a)

って書いても、意味の通るように改行をセミコロンとして解釈するから
var a;
a=3;
console.log(a);
と解釈するらしい。そんな書き方せんやろと思ったけどね。
ただ、どっちにも取れる表現の場合はうまく動かない
x
＋＋
y
だと、x++;y;にもx;++y;にも取れるから思った通りに動かんよという話。
要はセミコロンちゃんとつけようねって話が書いてあった。

３章　型、値、変数

「オブジェクト指向とは、グローバルに定義された関数を使って様々な型の値を処理するのではなく、
その型で定義された”メソッド”を使って値を処理するような考え方です。
配列aの要素をソートする場合、sort()関数の引数にaを指定するのではなく、
配列aのsort()メソッドを呼び出すのがオブジェクト指向な考え方です。」
var a=[1,2,3];
a.sort(); 


この説明分かり易いなー。
メソッドを用意するために、コンストラクタ関数を作って、プロトタイプオブジェクトに継承させてくイメージ。
ーーーー

普通の文字列や数字にもプロパティが存在しているのは、インタプリタがnew Stringやnew Numberを呼び出してメソッドを継承しているから。
ただし、プロパティに値を設定する場合は無視される。以下の場合、tの値はundefinedになる。
文字列などがプロパティにアクセスする際、一時的に生成されるオブジェクトのことを”ラッパーオブジェクト”と言う。
ラッパーオブジェクトはすぐに捨てられてしまうため、s.len=4;という値の設定も捨てられてしまう。よってtはundefinedになってしまう。

var s ="test";
s.len=4;
var t =s.len

ーーーー
関数スコープは、関数ないで宣言された変数を関数全体からアクセス可能とする。
以下の例の場合、最初のconsole.logの結果は”undefined”になる。
関数全体で有効なため、ローカル変数”scope”の内容がconsoleされ、未定義”undefined”が表示される。
このように宣言より前からローカル変数にアクセスできる機能をホイスティングと呼ぶ。

var scope="global";
function f(){
    console.log(scope);
    var scope="local;
    consoleog(scope);
}

ーーーーP６３まで





