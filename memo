memo
２章　字句構造
あんまり書く事ない。
JSのインタプリタが優秀だなぁ。くらい。
var a
a
=
3
console.log(a)

って書いても、意味の通るように改行をセミコロンとして解釈するから
var a;
a=3;
console.log(a);
と解釈するらしい。そんな書き方せんやろと思ったけどね。
ただ、どっちにも取れる表現の場合はうまく動かない
x
＋＋
y
だと、x++;y;にもx;++y;にも取れるから思った通りに動かんよという話。
要はセミコロンちゃんとつけようねって話が書いてあった。

３章　型、値、変数

「オブジェクト指向とは、グローバルに定義された関数を使って様々な型の値を処理するのではなく、
その型で定義された”メソッド”を使って値を処理するような考え方です。
配列aの要素をソートする場合、sort()関数の引数にaを指定するのではなく、
配列aのsort()メソッドを呼び出すのがオブジェクト指向な考え方です。」
var a=[1,2,3];
a.sort(); 


この説明分かり易いなー。
メソッドを用意するために、コンストラクタ関数を作って、プロトタイプオブジェクトに継承させてくイメージ。
ーーーー

普通の文字列や数字にもプロパティが存在しているのは、インタプリタがnew Stringやnew Numberを呼び出してメソッドを継承しているから。
ただし、プロパティに値を設定する場合は無視される。以下の場合、tの値はundefinedになる。
文字列などがプロパティにアクセスする際、一時的に生成されるオブジェクトのことを”ラッパーオブジェクト”と言う。
ラッパーオブジェクトはすぐに捨てられてしまうため、s.len=4;という値の設定も捨てられてしまう。よってtはundefinedになってしまう。

var s ="test";
s.len=4;
var t =s.len

ーーーー
関数スコープは、関数ないで宣言された変数を関数全体からアクセス可能とする。
以下の例の場合、最初のconsole.logの結果は”undefined”になる。
関数全体で有効なため、ローカル変数”scope”の内容がconsoleされ、未定義”undefined”が表示される。
このように宣言より前からローカル変数にアクセスできる機能をホイスティングと呼ぶ。

var scope="global";
function f(){
    console.log(scope);
    var scope="local;
    consoleog(scope);
}

4章　式と演算子

in演算子：左側の値が右側のオブジェクトのプロパティ名であればtrueを返す
定義したオブジェクトや配列要素に含まれないものがfalse
左側の値は文字列（または文字列変換可能なもの）でなければならない。

var point = {x:1,y:1};
"x" in point; //true
"z" in point; //false

ーーーー

instanceof演算子：左側のオブジェクトが右側のクラスのインスタンスであればtrue

var d = new date();
d instanceof Date; //true
d instanceof Number; //false


デバックに使えそうな二つの演算子。
ーーーー

＆＆演算子が単体でも効果を発揮する。２つのオペランドを評価せず、
左側のオペランドから順番に評価するためこのような動作が可能になる。
以下の例の場合、まずa==bを評価し、falseのとき右側は評価されない。
よってif(a==b) stop();と同じ動作をする

(a==b) && stop();

ーーーー
｜｜演算子も同様で、左から順番に評価をしtrueのものがあればその値を返す
いくつかの候補の中から定義されているものを使用した時などに使う。
以下例の場合、pにオブジェクトが渡されていない場合（pが未定義）の場合、空のオブジェクトを生成する

function copy(o,y){
    p = p || {};
}

ーーーー

グローバルevalを使うと、関数ないでも独立したトップレベルのスクリプトとして実行できる。
使い道はよくわからんがなんかに使えそう。

var geval=eval;
var x="global",y="global";
function f(){
    var x= "local";
    eval("x +='changed';"); //ローカル変数xがスコープされる
    return x;
}
console.log(f(),x)  //localchanged global

function g(){
    var y = "local";
    geval("y += 'changed';"); //グローバル変数yがスコープされる
    return y;
}
console.log(g(),y); //local globalchanged

ーーーー

?:演算子は、先頭のオペランドがtrueのとき、２番目の値を、falseのとき３番目の値を返す。
これは簡単なif文と同じような使い方ができる。
以下の例の結果は同じだが、書き方は大分さっぱりしている。

greeting="hello" + (username ? username : "there");

greeting="hello";
if (username){
    greeting+=username;
}else{
    greeting+="there";
}

ーーーー

５章　文
関数定義文で定義された関数は、暗黙的にこの関数を含むスクリプトや関数の先頭にホイスティング（巻き上げ）されます。
したがって、定義された関数はスクリプト全体や、関数全体からアクセスできる。
var文の場合は、変数宣言だけが巻き上げられ、変数の初期化はvar文を記述した場所で行われる。
関数宣言文の場合は、関数名と関数本体が巻き上げられるので、関数宣言よりも前のコードから関数を呼び出せる

ーーーー
switch文を関数内に記述する場合は、breakの代わりにreturnが使える。
以下の例はxの肩に応じて値を文字列に変換している。

function convert(x){
    switch(typeof x){
        case 'number':
            return x.tostring(16);
        case 'string':
            return '"' + x + '"';
        default:
        return string(x);
    }
}

ーーーー
for文の初期化値やインクリメントは、カンマ演算子で複数宣言できる。

for(i=0,j=0; i<10; i++,j++){
    sum += i*j;
}

ーーーー
for文の初期化値、テスト式、インクリメントはいずれも省略が可能。
テスト式を省略すると無限ループになる。
以下の例は、oオブジェクトの中のnextプロパティが含まれない最初のオブジェクトを返す。

function tail(o){
    for(; o.next; o=o.next) /* 空文 */;  //初期化値を省略。さらにforのステートメントは空文で記述して、インクリメントの場所でoにオブジェクトを代入している。
    return o;
}

ーーーー
先頭に識別子、その後ろにコロン、最後にステートメントを記述することで、任意の文にラベルを設定することができる。
文にラベルをつけておけば、プログラムの他の場所からラベル名で参照ができる。
通常はループ文や条件文などの本体部分をもつ物にラベルをつけることでbreakやcontinueを使ってループの先頭に戻り、次のループを開始できる。
ネストされた繰り返しなどで、中断、あるいはスキップしたい位置が最も内側の繰り返しでない時に活用できる。

var matrix = getData();
var sum=0, success=false;
compute_sum:if(matrix){
    for(var x=0; x<matrix.length; x++){
        var row = matrix[x];
        if(!row) break compute_sum; //rowがfalseのときbreakする。このときbreakされるのは、forではなくラベルcompute_sumのif。
        for(var y=0; y<row.length; y++){
            var cel =row[y];
            if(isNaN(cell)) break compute_sum; //cellがNaNだった場合、compute_sumの位置でbreakする。
            sum += cell;
        }
    }
    success=true;
}
console.log(success); //ネストされた繰り返しが全て実行されていればtrue、そうでなければfalseが表示される

ーーーー
例外処理（throw/try/catch/finally）：
throw文を使ってプログラム中で明示的に記述した場合に、例外がスローされる。
例外をキャッチするには、try/catch/finally文を使います。
try句には例外処理の対照ろなるコードブロックを記述し、その後にcatch句を記述する。
catch()句には、例外が発生した時に呼び出される文を記述し、その後にfinally句を記述する。
finally句にはtryやcatch句の処理が終了した後に必ず実行される文を記述する。
catch句とfinally句は、どちらかを省略することが可能。

function factorial(x){    
    if(x < 0) throw new Error("x must not be nagative"); //引数が無効であれば例外をスローする。
    
    for(var f=1; x>1; f *= x,x--) /* 空文 */;
    return f
}

try{
    var n = Number(prompt("Please enter a positive integer","")); //ユーザーに数値入力を要求
    var f = factorial(n); //関数の結果をfに代入
    alert(n + "!=" + f); //結果を表示
}
catch(ex){
    alert(ex); //エラーが発生した時は、Errorオブジェクトを引数として受け取り”x must not be nagative”を表示
}
//finaly句は省略

ーーーー

６章　オブジェクト
オブジェクトとは”プロパティ”の集合である。オブジェクト自身のプロパティ以外に、
他のオブジェクトからプロパティを継承することもできます。
この継承対象となるオブジェクトを”プロトタイプ”と呼び、オブジェクトのメソッドは継承プロパティの場合が普通です。

文字列、数値、ture、false、null、undefinedでもない値がオブジェクトです。
ただし、文字列、数値、論理値はラッパーオブジェクトに変換される場合があります。

ーーーー
プロパティにはプロパティ属性と呼ばれるものをもつ。
・書き込み可
・列挙可
・再定義可

プロパティの分類
・独自プロパティ：オブジェクトに対して直接定義されたプロパティ
・継承プロパティ：オブジェクトのプロトタイプオブジェクトで定義されたプロパティ

オブジェクトはプロパティの他にオブジェクト属性をもつ。
・プロトタイプ：プロパティの継承元となるオブジェクトの参照
・クラス：オブジェクトの型を表す文字列
・拡張可フラグ：新しいプロパティを追加できるかどうか示すフラグ

オブジェクトの分類
・ネイティブオブジェクト：ECMAScriptで定義されているオブジェクト、またはオブジェクトのクラス
・ホストオブジェクト：webブラウザなどJSのインタプリタが組み込まれたホスト環境で定義されたオブジェクト
・ユーザ定義オブジェクト：JSコードを実行した結果生成されたオブジェクト


